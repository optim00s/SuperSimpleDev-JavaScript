<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Advanced Functions</title>
  </head>
  <body>
    <button onclick="" class="js-button">Click</button>
    <script>
        //Review: How to use functions
        // /*
        //   funksiya sayəsində kodu 
        //   yenidən istifadə edə bilirik
        // */
        // function greeting() {
        //   console.log('hello');
        // }

        // /*
        //   bu kod funksiyanı çağırmaq 
        //   adlanır

        //   calling the function or 
        //   running the function
        // */
        // greeting();

        // /*
        //   function are values

        //   funksiyalar sadəcə, digər value
        //   tipidir.

        //   funksiyalar value olduğuna görə,
        //   onları string, numbers, booleans kimi 
        //   variable daxilində saxlaya bilərik

        //   variable daxilində saxlayarkən,
        //   sona ; işarəsini qoymaq lazımdır.
        // */
        // const num = 2;

        // //function inside a variable
        // const function1 = function greeting() {
        //   console.log('hello2');
        // };

        // console.log(function1);
        // console.log(typeof function1);

        // /*
        //   variable funksiya ehtiva etdiyini
        //   görə, variablein adını yazaraq çağıra
        //   bilərik.
        // */
        // function1();

        // /*
        //   JS-də, funksiya daxil olmaq üçün, yol varsa
        //   funksiya adı lazım deyil.

        //   const function1 = function greeting() {
        //     console.log('hello2');
        //   };

        //   burda, funksiyaya variabledan istifadə 
        //   edərək daxil oluruq və funksiya adı lazımlı
        //   deyil.

        //   const function1 = function() {
        //     console.log('hello2');
        //   };

        //   bu Anonymous Function (function without a name) 
        //   adlanır.
        // */

        // /*
        //   Əslində, kurs boyunca olan funksiya syntaxı

        //   function greeting() {
        //     console.log('hello');
        //   }
        //   greeting();

        //   var greeting = function() {
        //     console.log('hello');
        //   }

        //   bunun shortuctu idi.

        //   Ancaq, birinci syntaxin iki üstünlüyü var
        //   1. Easier to read
        //   2. Hoisting (qaldırma)

        //   Hoisting o deməkdir ki, funksiyanı
        //   funksiya yaranmamışdan qabaq çağıra bilərik.
      
        //   greeting();   

        //   function greeting() {
        //     console.log('hello');
        //   }
       
        //   hoisting, variable daxilində saxlanan 
        //   funksiyalarda işləmir
        // */

        // //we can save a value in object

        // /*
        //   property: value
        //   funksiyalarda value olduğundan, onlarıda
        //   object daxilində saxlaya bilərik.

        //   beləliklə, fun propertysi altında, obyekt
        //   daxilində funksiya saxladıq.
        // */
        // const object1 = {
        //   num: 2,
        //   fun: function() {
        //     console.log('hello3');
        //   }
        // };

        // /*
        //   funksiyaya daxil olmaq üçün,
        //   dot notasiyasından istifadə edirik.

        //   və funın valuesu funksiya olduğundan 
        //   onu çağıra bilərik

        //   bu method (function saved inside object) idi.
        // */
        // object1.fun();

        // //we can pass a value into a function

        // function display(param) {
        //   console.log(param);
        // }

        // /*
        //   bu, passing a value into function
        //   olaraq bilinir.
        // */
        // display(2);

        // /*
        //   funksiyalarda value olduğundan, 
        //   funksiyaya, funksiya göndərə bilərik.

        //   param bu anonymous funksiyasını
        //   daxilində saxlayacaq.
        //   function() {
        //     console.log('hello4');
        //   }

        //   paramı varaible kimi istifadə edə 
        //   bilərik.
        //   və o funksiya ehtiva etdiyini görə
        //   çağırırıq.
        // */
        // function run(param) {
        //   param();
        // }
        // /*
        //   bu, passing a function into another 
        //   function adlanır

        //   göndərdiyimiz funksiya, callback function
        //   və ya callback adlanır.
        // */
        // run(function() {
        //   console.log('hello4');
        // });

        // /*
        //   xülasə, funksiyalar valuelardır.
        //   valuelar ilə nə edə biliriksə,
        //   funksiyalarlada onları edə bilərik.
        // */

        // //PRACTICAL EXAMPLES

        // //setTimeout() and Asynchronous Code

        // /*
        //   setTimeout()
        //   allows us to run a function in the future

        //   setTimeout built-in funksiyadır. 
        //   iki parameter alır
        //   1. gələcəkdə işlədəcəyimiz funksiya
        //   (bunu eləyəndə, value olaraq funksiya istifadə edirik
        //   və funksiyanı başqa funksiyaya göndəririk)
        //   2. bu funksiyanı işə salmaq üçün gözləmə müddəti
        //   (a number in milliseconds)

        //   setTimeout(function() {
        //     console.log('timeout')
        //   }, 3000);

        //   bu setTimeout 3 saniyə gözlədikdən sonra,
        //   funksiyanı işə salacaq.
        // */
        // setTimeout(function() {
        //   console.log('timeout')
        //   console.log('timeout2')
        // }, 3000);

        // /*
        //   ilk olaraq next line və 
        //   3 saniyə sonra timeout göstərilir.

        //   Burda nə baş verir, niyə bunlar
        //   tərsinədir?

        //   setTimeout timer qurur və 3 saniyə 
        //   sonra funksiyanı çağırır. 

        //   bitməsi üçün 3 saniyə gözləmir, timeri 
        //   qurur və anındaca növbəti sətrə keçir.

        //   buna görə next line birinci göstərilir.

        //   bu Asynchronous Code adlanır
        //   won't wait for a line to finish 
        //   before going to the next line

        //   növbəti sətrə keçməzdən əvvəl, həmin sətrin
        //   bitməsini gözləməyəcək 

        //   Synchronous Code
        //   will wait for one line to finish
        //   before going to the next line 

        //   növbəti sətirə keçməzdən əvvəl, sətrin 
        //   bitməsini gözləyəcək

        //   setTimeout() daxilindəki kod da, 
        //   synchronous koddur.

        //   setTimeout(function() {
        //     console.log('timeout')
        //     console.log('timeout2')
        //   }, 3000);

        //   3 saniyə sonra,
        //   timeout
        //   timeout2 
        //   göstəriləcək

        //   setTimeoutun asynchronous olmasının
        //   üstünlüyü odur ki, kodumuzu 3 saniyə üçün bloklamır.
        //   arxada timer qurur və növbəti kod sətrinə keçir.

        //   bu kodumuza, timer arxada davam edərkən, digər
        //   şeylər eləməyə imkan verir.

        //   və bu real həyata oxşardır. alarm clockda timer 
        //   qursanız, dayanıb timerin bitməsini gözləməyəcəksiniz.
        //   davam edib, başqa bir şey edəcəksiniz.

        //   asynchronous kodda eyni konseptdədir
        // */
        // console.log('next line');

        // //setInterval()


        // /*
        //   setInterval built-in funksiyadır.

        //   setInterval(), setTimeout() la eyni iki
        //   parametri alır.
        //   1. gələcəkdə işlədəcəyimiz funksiya
        //   2. bu funksiyanı işə salmaq üçün gözləmə müddəti
        //   (a number in milliseconds)

        //   setInterval, bu funksiyanı 3 saniyə sonra
        //   işə salacaq. 
        //   ancaq, hər 3 saniyədən bir funksiyanı yenidən
        //   işlədəcək.

        //   setIntervalda async funksiyadır
        //   intervalı təyin edib, anındaca növbəti sətrə
        //   keçəcək

        //   setInterval()
        //   it will keep running a function 
        //   in the future

        //   setInterval() ı necə dayandıra bilərik?

        //   əslində, setInterval() number qaytarır.
        //   və bu number, ID kimidir. bu ID-dən istifadaə
        //   edərək, intervalı dayandıra bilərik.

        //   clearInterval() built-in funksiyası ilə 
        //   bunu edirik. mörtərizələr daxilində dayandırmaq
        //   istədiyimiz ID ni daxil edirik.

        //   //sonuncu intervalin IDsini alırıq
        //   let intervalId;

        //   intervalId = setInterval(function() {
        //     const playerMove = pickComputerMove();
        //     playGame(playerMove);
        //   }, 1000);

        //   clearInterval(intervalId);
        // */
        // setInterval(function() {
        //   console.log('interval');
        // }, 3000);

        // console.log('next line 2');
        
        // //Loop through an array

        // /*
        //   arraydən keçmək üçün,
        //   for/while loopdan istifadə edirdik.

        //   bunun digər yolu isə, forEach() adlanan
        //   arrayin methodundan istifadə etməkdir.

        //   forEach() in mörtərizələri daxilində arrayin
        //   hər dəyəri üçün funksiya daxil edirik.

        //   yenə, funksiya daxilinə funksiya ötürürük.

        //   ancaq, ötürülən funkisiya parameterlərə sahib olacaq.

        //   forEach() tam olaraq, arrayin içindən keçəcək və
        //   hər bir value üçün, həmin valuenu parametrdə saxlayacaq 
        //   və funksiyanı işə salacaq.

        //   forEach() is the preferred way to 
        //   loop through an array

        //   çünki, for loopu oxumaqdan daha rahatdır.
        //   həm də, forEach() in ikinci parameteri indexdir.

        //   əvvəlki, dərslərdə loopların continue, break
        //   xüsusiyyətini öyrənmişdik.

        //   continue
        //   növbəti artıma/addıma ötürməyimizə kömək edir.

        //   forEach() mehtodunda, continue yoxdur. 
        //   ancaq eyni şeyi return statement ilə edə bilərik.
 
        //   . . .
        //   if (value === 'wash dishes') {
        //     return;
        //   }
        //   . . .

        //   return, bu funksiyanı erkən dayanadıracaq və
        //   növbəti funksiyaya keçəcək.

        //   təməl olaraq, for loopdakı continue ilə eyni şey edir.

        //   break
        //   loopdan erkən çıxmağımıza kömək edir.

        //   forEach() loopunda, break etməyin 
        //   asan yolu yoxdur. 

        //   breakdən istifadə edib, loopdan erkən çıxmalıyıqsa,
        //   onda for loopdan istifadə etməliyik.
        // */
        // [
        //   'make dinner', 
        //   'wash dishes',
        //   'watch youtube'
        // ].forEach((value, index) => {
        //   if (value === 'wash dishes') {
        //     return;
        //   }
        //   console.log(value, index);
        // });

        // //Arrow Function (a shorter way to write functions)

        // /*
        //   Arrow Function
        //   (mostly works the same as a regular function)

        //   fərqlərindən biri odur ki, function sözü yerinə
        //   => arrow işarəsindən istifadə edir.

        //   function() {}
        //   () => {}

        //   ortaq cəhətlər:
        //   parameterlər, arrow funksiyasında eyni 
        //   formada işləyir. 

        //   parameterləri, () daxil edirik.

        //   çoxlu parameterlərdə, eyni formada işləyir.

        //   return statement də, arrow funksiyasında eyni
        //   formada işləyir.

        //   fərqli cəhətlər:
        //   arrow funksiyaları, regular funksiyada olmayan
        //   bəzi shortcutlara sahibdir.

        //   1.
        //   const oneParam = (param) => {
        //     console.log(param + 1);
        //   };

        //   arrow funksiyası tək parameterə 
        //   sahibdirsə, () optional olur.

        //   const oneParam = param => {
        //     console.log(param + 1);
        //   };

        //   2.
        //   const oneLine = () => {
        //     return 2 + 3;
        //   }

        //   arrow funksiyası tək sətrdən ibarətdirsə, 
        //   kodu arrowla eyni sətrə qoya bilərik.

        //   const oneLine = () => { return 2 + 3; };

        //   indi hər şey eyni sətrdə olduğundan, {} 
        //   optional olur, həmçinin return statementidə silə bilərik.

        //   const oneLine = () => return 2 + 3;

        //   arrow olduğudan sağdakı nəticəni avtomatik olaraq
        //   return edəcək.

        //   funksiyanı, başqa bir funksiyaya ötürərkən,
        //   arrow funksiyası istifadə etmək tövsiyyə ediləndir.
          
        //   çünki, o kodumuzu oxumağı asanlaşdırır.

        //   forEach((value, index) => {
        //     if (value === 'wash dishes') {
        //       return;
        //     }
        //     console.log(value, index);
        //   });

        //   proyektlərdə arrow funksiyası:
        //   RPS proyektindəki, autoPlay funksiyanı nümunə
        //   olaraq götürək.

        //   const autoPlay = () => {

        //   }

        //   function autoPlay() {

        //   }

        //   arrow yoxsa regular funksiyanı seçməliyik?

        //   regular.
          
        //   çünki,
        //   1. regular funksiyanı oxumaq daha rahatdır
        //   2. regular funksiya syntaxı hoistingi açır.
        //      yəni, funksiyanı yaratmazdan əvvəl, çağıra bilərik.

        //   objectlər daxilində arrow funksiyaları:  
        //   const object2 = {
        //     method: () => {

        //     }
        //   };

        //   arrow funksiyaları object daxilində yerləşdirsək
        //   belə, object funksiyalar üçün shortcuta sahibdir.

        //   shorthand method syntax:
        //   const object2 = {
        //     method() {

        //     }
        //   };

        //   həmçinin, shorthand methodu oxumaq arrow funksiyan;
        //   oxumaqdan daha rahatdır.

        //   object daxilində funksiya saxlayarkən, 
        //   shorthand methodundan istifadə etmək 
        //   tövsiyyə olunandır.
        // */

        // const regularFunction = function(param, param2) {
        //   console.log('hello');
          
        //   return 5;
        // };

        // const arrowFunction = (param, param2) => {
        //   console.log('hello');

        //   return 5;
        // };
        // arrowFunction();

        // const oneParam = param => {
        //   console.log(param + 1);
        // };
        // oneParam(2);

        // const oneLine = () => 2 + 3;
        // const x = oneLine();
        // console.log(x);

        // const object2 = {
        //   method: () => {

        //   },
        //   method() {

        //   },
        //   ssi() {
        //     console.log('ssi');
        //   }
        // };

        // object2.ssi();

        // // .addEventListener()

        // /*
        //   hər HTML elementinin .addEventListener(); adlı mehtodu var

        //   addEventListener() elementlə qarşılıqlı əlaqədə 
        //   olduğumuzda bizə, bəzi kodları işlətməyə imkan verir.

        //   bir növ onclick ilə eyni şeyi edir.

        //   addEventListener() iki parameterə sahibdir:
        //   1. event (və ya hansı növ qarşılıqlı əlaqəni dinləmək istəyirik)
        //   2. event olduqda işə salacağımız funksiya

        //   event adlarını attributelarda tapa bilərik, 
        //   on_click_ dan sonra gələnlər eventdir.

        //   buttonElement.addEventListener('click', () => {
        //     console.log('click');
        //   });

        //   buttona kliklədiyimzdə arrow funksiya işə düşəcək.
        //   bu kod, onclick atributu ilə eyni şeyi edir.
        //   ancaq, attribute istifadə etmək əvəzinə addEventListener
        //   istifadə etməyin bəzi üstünlükləri var.

        //   1. event üçün, çoxlu event listener 
        //   əlavə etməyə imkan verir

        //   buttonElement.addEventListener('click', () => {
        //     console.log('click');
        //   });

        //   buttonElement.addEventListener('click', () => {
        //     console.log('click2');
        //   });         
          
        //   buttona kliklədiyimizdə bu iki 
        //   funksiyanı işə salacaq
          
        //   2. removeEventListener(); istifad edərək
        //   event listeneri silə bilərik

        //   removeEventListener() iki parameterə sahibdir:
        //   1. event
        //   2. silmək istədiyimiz funksiyadır
  
        //   silmək istədiyimiz funksiyanı, addEventListenerdən
        //   copy paste eləyə bilmərik. 
        //   bu funksiyanın eynisini istifadə etməliyik. 
          
        //   buna görə də, funksiyanı variableda saxlayırıq.

        //   const eventListener = () => console.log('click');

        //   addEventListener, event listenerlər üstündə bizə
        //   daha çox idarə verir.

        //   1. Add multiple event listener
        //   2. Remove an event listener

        //   best practice:
        //   use addEventListner(); instead of onclick=" "

        //   proyektlərdə addEventListener():

        //   rockButton.addEventListener('click', 
        //     playGame('rock')
        //   );

        //   burda ümumi səhv odur ki, parameter olaraq
        //   funkiya daxil etmək əvəzinə, işə salmaq
        //   istədiyimiz funksiyanı daxil edirik.

        //   biz əslində addEventListener() ə funksiya verməliyik,
        //   ancaq playGame('rock') funksiyasının resultunu veririk.

        //   playGame() funksiyası işə düşəcək və bizə 
        //   return valuesunu olan undefineddı verəcək.

        //   və bizdə addEventListener() ə undefined veririk.

        //   beləliklə, kod işləməyəcək.

        //   rockButton.addEventListener('click', () => {
        //     playGame('rock');
        //   });

        //   qeyd:
        //   event - a special object
  
        //   event objecti hansı keyin basılmasını özündə ehtiva edir
        //   event.key

        //   addEventListener() də, event objectini təmin edir.
        //   ancaq onu, funksiyaya parameter olaraq təmin edir.

        //   document.body.addEventListener('keydown', (event) => {

        //   });

        //   hər dəfə klaviyaturamızda yazanda, addEventListener() 
        //   event objectini, arrow funksiyasının parameteri 
        //   olaraq saxlayıb funksiyanı işə salacaq.

        //   bu event objecti, basdığımız düyməni ehtiva edir.

        //   querySelectorAll(); daxilindəki classa sahib bütün
        //   elementləri HTMLdən əldə edib, NodeList (array) 
        //   daxilində yığır.
        // */
        // const buttonElement = document.querySelector('.js-button');

        // const eventListener = () => console.log('click');

        // buttonElement.addEventListener('click', 
        //   eventListener
        // );

        // buttonElement.removeEventListener('click',  
        //   eventListener
        // );

        // buttonElement.addEventListener('click', () => {
        //   console.log('click2');
        // });

        // more features that use functions as values

        /*
           filter();

           forEach() ilə eyni formada işləyir.

           filter() ə funksiya veririk və 
           bu funksiya iki parameterə sahibdir.

           1. value
           2. index

           tək fərq odur ki, daxili funksiya 
           value qaytaracaq.

           return olancaq value, booleandır.

           filter()
           1. yeni array yaradacaq
           2. return truedursa, valuenu arraya qoyacaq
           3. return falsedursa, valuenu arraya qoymacaq

           console.log(
            [1, -3, 5].filter((value, index) => {
              if (value >= 0) {
                return true;
              } else {
                return false;
              }
            });           
           );

           truthy və falsy valuelardan istifadə edərək
           kodu qısalda bilərik

           console.log(
            [1, -3, 5].filter((value, index) => {
              return value >= 0;
            })
           );
        */ 

        console.log(
            [1, -3, 5].filter((value, index) => {
              return value >= 0;
          })
        );


        /*
          map();

          forEach() və filter() ilə eyni formada işləyir.

          map() ə funksiya veririk və 
          bu funksiya iki parameterə sahibdir.

          1. value
          2. index

          funksiya value qaytaracaq.

          map()
          1. yeni array yaradacaq
          2. nə return ediriksə, yeni arraya əlavə olunacaq

          console.log(
            [1, 1, 3].map((value, index) => {
              return 10;
            })
          );

          new array is [10, 10, 10]

          maraqlı tərəf odur ki, returnda 
          valuenun özündən istifadə edə bilərik.

          console.log(
            [1, 1, 3].map((value, index) => {
              return value + 10;
            })
          );

          new array is [11, 11, 13]

          map() = transform an array into another array 
          (based on return value)
        */

        [1, 1, 3].map((value, index) => {
          return 10;
        });

        console.log(
          [1, 1, 3].map((value, index) => {
            return value * 2;
          })
        );

        // shortcuts of arrow functions

        console.log([1, 1, 3].map(value => value * 2));

        /*
          closure 
          if a function has access to a value
          it will always have access to that value

          valuegets packaged together (enclosed)
          with the function

          əgər funksiyanın valueya əlçatanlığı varsa,
          o həmişə həmin valueya əlçatanlığı olacaq

          value funksiya ilə birlikdə paketlənir (əlavə olunur)

          buna görə closure (bağlanma) deyirik.

          deleteButton.forEach((deleteButtonElement, index) => {
            deleteButtonElement.addEventListener('click', () => {
                todoListWithDate.splice(index, 1);
                renderToDoListWithDate();
            });
          });

          addEventListener() dəki innner funksiyaya fokuslanacağıq
          bu funksiya, forEach() dəki indexdən istifadə edir.

          index haqqında maraqlı məqam odur ki, 
          forEach() bitən kimi, index silinir.

          deleteButton.forEach((deleteButtonElement, index) => {
            deleteButtonElement.addEventListener('click', () => {
                todoListWithDate.splice(index, 1);
                renderToDoListWithDate();
            });
          });

          console.log(index);

          forEach() bitən kimi, index silindiyindən,
          consoleda index 'is not defined' görürük.

          ancaq, console.log(index) i 
          inner funksiyaya aparsaq

          deleteButton
            .forEach((deleteButtonElement, index) => {
              deleteButtonElement.addEventListener('click', () => {
                  console.log(index);
                  todoListWithDate.splice(index, 1);
                  renderToDoListWithDate();
              });
          });

          forEach() bitən kimi, index silinir 
          və delete buttonuna kliklədiyimizdə 
          consoleda '0' görəcəyik.

          çünki, delete buttonu render olunan vaxt, 
          forEachdəki index valuesuna əl çatan idi.
          və closure görə, index silinsə belə 
          yenə əlçatan olmağa davam edir.

          index valuesu loop bitdikdən sonra silinəndən, 
          5 saniyə və ya 5 dəqiqə sonra delete buttona 
          klikləsək belə, bu funksiyanın indexə 
          əlçatanlığı həmişə olacaq

          beləki, closure JS kodu yazarkən natural olaraq
          baş verir.
        */
    </script>
  </body>
</html>
 